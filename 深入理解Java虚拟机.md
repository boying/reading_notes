---
title: 深入理解Java虚拟机
tags: java,虚拟机,jvm
grammar_cjkRuby: true
---


## 虚拟机性能监控与故障处理工具

### jdk命令行工具

#### jps

列出正在运行的虚拟机进程

#### jstat

监视虚拟机运行状态信息,显示本地或远程虚拟机中的类加载、内存、垃圾收集、JIT编译等运行数据
demo:
jstat -gcutil 120 250 100
每隔250毫秒查看进程120的GC情况

#### jinfo

查看或修改虚拟的各项参数

#### jmap

生成堆转储快照
demo:
jmap -dump:format=b,file=idea.bin 2285

#### jhat

堆转储快照分析工具
demo:
jhat idea.bin

#### jstack

生成虚拟机当前时刻线程快照（线程正在执行的方法堆栈）

### jdk可视化工具

#### JConsole

内存监控；线程监控

#### VisualVM

生成、浏览堆转储快照；分析程序性能
***BTrace***
在不停止程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态地加入原本并不存在的调试代码

## 虚拟机类加载机制

### 类的生命周期

加载--> 验证--> 准备--> 解析--> 初始化 --> 使用 --> 卸载

### 类初始化时机

“有且只有”触发下面这5个场景，将会进行类初始化
1. 遇到new、getstatic、putstatic、invokestatic这4个字节码指令。对应的使用场景：new实例化对象、读取或设置类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用静态方法
2. 使用java.lang.reflect对类进行反射
3. 当初始化一个类时，如果其父类没有初始化，将先初始化父类
4. 虚拟机启动，虚拟机会先初始化主类（包含main方法的那个类）
5. JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄时

### 初始化 \<clinit\>

类初始化时类加载的最后一步，才真正开始执行类中定义的java代码
在准备阶段，变量已经赋过系统要求的初始值，在初始化阶段，则根据程序员指定的主管计划去初始化类变量和其他资源。初始化是执行类构造器\<clinit\>方法的过程
* \<clinit\>方法是由编译器自动收集类中所有静态变量赋值动作和静态语句块（static {}）中的语句合并产生的
* \<clinit\>不需要显示地调用父类构造器，虚拟机会保证在子类构造方法调用之前，父类的构造方法已近执行完毕
* 父类构造方法先执行，以为这父类中定义的静态语句块要先于子类变量的复制操作
* \<clinit\>并不是必须的，如果累没有对静态变量的赋值操作，编译器可以不生成\<clinit\>方法
* 接口\<clinit\>方法不要先执行父接口的\<clinit\>方法，只有父接口中定义的变量使用时，福接口才会初始话。接口的实现类在初始化时不会执行接口的\<clinit\>方法
* 虚拟机会保证一个类的\<clinit\>方法在多线程环境中被正确加锁，同步

### 类加载器

#### 什么是类加载器

类加载器“通过一个类的全限定名来获取描述此类的二进制字节流”。此动作在Java虚拟机外部实现，以便让程序自己决定如何去获取所需要的类

#### 类的唯一性

对于任意一个类，都需要有加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。

#### 双亲委派模型

3种系统提供的类加载器
1. 启动类加载器（Bootstrap ClassLoader）
   将存放在<JAVA_HOME>/lib目录中，或者被-Xbootclasspath参数所指定路径中的，并且是虚拟机识别的（仅按文件名识别）类库加载到虚拟机内存中。该加载器无法被程序直接引用。
2. 扩展类加载器（Extension ClassLoader）
   加载<JAVA_HOME>/lib/ext中，或被java.ext.dirs系统变量指定路径中所有类库。开发者可直接使用该加载器。
3. 应用程序类加载器（Application ClassLoader）/ 系统类加载器
   该加载器是ClassLoader中的getSystemClassLoader()方法的返回值。它加载用户路径(ClassPath)上所指定的类库，开发者可直接使用，如果程序没有自定义过自己的类加载器，该加载器一般情况下就是默认的加载器。


工作过程：
如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载该类，二是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类家在其中，只有当父类加载器反馈自己无法加载这个请求（它的搜索范围内没有找到所需的类），子加载器才会尝试自己去加载。

好处：
Java类随着它的类加载器一起具备了带有优先级的层次关系。例如java.lang.Object类，无论哪个加载器加载该类，最终都委派给顶端启动类加载器来加载，保证了Object类在各种类加载器环境中都是同一个类。

## 早期（编译期）优化

### 语法糖

Java中常用的语法糖有：泛型、自动装箱/拆箱、变长参数、遍历循环等，虚拟机运行时不支持这些语法，它们在编译期还原回简单的基础语法结构，这个过程称为解语法糖。

### 泛型 类型擦除 伪泛型

Java泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并且在相应的地方插入了强制转型代码。对于运行期的Java语言来说，ArrayList\<int\> 与ArrayList\<String\>就是同一个类。
泛型是Java的一个语法糖，实现方式呗称为类型擦除，这种泛型被称为伪泛型。

Java泛型的主要目的: 在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率

可以看到Java泛型的主要目的是类型检查和自动类型转换, 而非更好的泛化, 所以有人说Java的泛型不是真正的泛型, 只是伪泛型

没理解：
http://www.cnblogs.com/fxjwind/p/3463266.html

下面的泛型重载将编译不过
```
public class C{
    public static int f(List<String > list){return 1;}

    public static String f(List<Integer> list){return "";}
}
```


### 装箱、拆箱与遍历循环

编译前
```
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1,2,3,4);
        int sum = 0;
        for(int i : list){
            sum += i;
        }
        System.out.println(sum);
    }
```
“编译”后
```
    public static void main(String[] args) {
        List list = Arrays.asList(new Integer[]{
                Integer.valueOf(1),
                Integer.valueOf(2),
                Integer.valueOf(3),
                Integer.valueOf(4)
        });
        int sum = 0;
        for(Iterator itr = list.iterator(); itr.hasNext();){
            int i = ((Integer) itr.next()).intValue();
            sum += i;
        }
        System.out.println(sum);
    }
```

## 晚期（运行期）优化

### JIT

为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行了各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler）。
JIT不属于java虚拟机规范，并不是必须部分，但JIT好坏衡量商用虚拟机是否优秀的最关键的指标之一，它是虚拟机中最核心且最能体现虚拟机技术水平的部分。

### 编译对象与触发条件

大致触发条件：
* 被多次调用的方法
* 被多次执行的循环体

编译对象：
整个方法


## 12 Java内存模型与线程

### 线程的实现3中方式，3中线程模型


#### 1. 使用内核线程实现

内核线程（Kernel-Level Thread，KLT）是直接由操作系统内核支持的线程，由内核完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度。
程序一般不会直接去使用内核线程，二是去使用啮合线程的一种高级接口——**轻量级进程（Light Weight Process, LWP）**，轻量级进程就是我们通常意义上讲的线程。
每个轻量级进程都由一个内核线程支持，它们1:1的关系成为一对一线程模型。

![enter description here][1]

**优点**
由于内核线程的支持，每个轻量级进程都是一个独立的调度单元，及时有一个轻量级进程在系统调用中阻塞了，也不会英雄昂到整个进程继续工作。

**缺点**
1. 基于内核线程实现，所以各种线程操作（创建、析构、同步）都需要系统调用。系统调用代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中切换。
2. 每个轻量级进程需要一个内核线程的支持，需要消耗一定的**内核资源**（如内核线程的栈空间），因此系统支持的轻量级进程**数量有限**。

**实际使用**

Sun JDK中使用一对一线程模型，一个Java线程映射到一条轻量级进程中。


#### 2. 使用用户线程实现

广义上讲，一个线程只要不是内核线程，就可以认为是用户线程
狭义上讲，用户线程指完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。
用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核帮助。
进程与用户线程之是1：N的一对多关系

![enter description here][2]

**优点**
线程不需要切换到内核态，操作可以是非常快速且低消耗的，也可以支持更大规模的线程数量

**缺点**
没有系统内核的支援，所有线程的操作都需要用户程序自己处理，使用用户线程实现的程序一般都比较复杂。线程的创建、切换和调度都需要考虑，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题将异常困难。


**实际使用**
部分高性能数据库中的多线程使用用户线程实现。
现在使用用户线程的程序越来越少，Java、Ruby曾使用过，但最终放弃。

#### 3. 使用用户线程加轻量级进程混合实现

用户线程完全建立在用户空间中，因此用户线程的创建、切换、析构等操作廉价，可支持大规模的用户线程并发。操作系统提供支持的轻量级进程作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射。
用户线程与轻量级进程的数量比例是不定的，为N:M的关系

![enter description here][3]

### Java的线程是什么

虚拟机规范中未限定Java线程需要使用哪种线程模型来实现。
目前JDK的版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的。

Sun JDK的windows和linux版本中使用一对一线程模型，一个Java线程映射到一条轻量级进程中。

### 线程状态及转换

**5**种线程状态

* 新建（New）：创建后尚未启动的线程出于此状态
* 运行（Runnable）：Runnable包含了操作系统线程状态中的Running和Ready，也就是出于此状态的线程有可能在执行，也有可能在等待CPU为它分配执行时间
* 无限期等待（Waiting）：出于这种状态下的线程不会被分配CPU执行时间，他们要等待其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：
    没有设置timeout的Object.wait()方法
    没有设置timeout的Thread.join()方法
    LockSupport.park()方法
* 限期等待（Timed Waiting）：出于这种状态的线程不会被分配CPU时间，不过无需等待被其他线程显示地唤醒，在一定时间之后他们会有系统自动唤醒。一下方法让线程进入期限等待状态。
    Thread.sleep()方法
    设置了timeout的Object.wait()方法
    设置了timeout的Thread.join()方法
    LockSupport.parkNanos()方法
    LockSupport.parkUntil()方法
* 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入阻塞状态。
* 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

![enter description here][4]

## 13 线程安全与锁优化

### ThreadLocal原理

每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值可以在线程K-V值对中找回对应的本地线程变量。

### 锁优化

#### 自旋锁与自适应自旋

#### 锁消除

#### 锁粗话

#### 轻量级锁

#### 偏向锁

锁会偏向第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如Locking，Unlocking等）
当另外一个线程去尝试获取这个锁时，偏向模式宣告结束

JVM启动参数 -XX:+UseBiasedLocking -XX:-UseBiasedLocking 可开关偏向功能




  [1]: ./assets/WechatIMG4.jpeg "WechatIMG4.jpeg"
  [2]: ./assets/WechatIMG3.jpeg "WechatIMG3.jpeg"
  [3]: ./assets/WechatIMG2.jpeg "WechatIMG2.jpeg"
  [4]: ./assets/WechatIMG1.jpeg "WechatIMG1.jpeg"