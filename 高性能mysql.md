---
title: 高性能mysql
tags: mysql
grammar_cjkRuby: true
---

## 索引
### B-Tree索引

InnoDB使用的是B+Tree
适用范围
1. B-Tree索引适用于全键值，键值范围，键值前缀查找。
2. 用于查询中的Order by操作（按顺序查找），如果order by子句满足查询类型，这个索引也可以满足对应的排序需求
限制
1. 如果不是按照索引的最左列开始查找，则无法使用索引
2. 不能跳过索引中的列
3. 如果查询中有某个列的查询范围，则其右边的所有列无法使用索引优化查找，即，只有最左列在查询范围时有效
所以，索引列的**顺序**非常重要
### 高性能索引的策略
#### 独立的列
索引不能是表达式的一部分，也不能是函数的参数。
错误的例子：
select * from actor where id + 1 = 5;
select * from actor where TO_DAYS(date) - TO_DAYS(date) < 10
应该简化where条件，将索引列单独放在比较符的一侧
#### 前缀索引和索引的选择性
索引的选择性是指，不重复的索引值和数据表的记录总数的比值，选择性越高，查询效率越高
对于BLOB，TEXT或者很长的VARCHAR类型的列，必须使用前缀索引。
要选择足够长的前缀来保证高的选择性，同时又不能太长（节约空间）
##### 如何决定前缀的长度？
![enter description here][1]
![enter description here][2]
![enter description here][3]

  
  #### 多列索引
  索引合并：查询能够同时使用两个单列索引进行扫描，将结果进行合并。有三个变种：OR条件的联合（union）,AND条件的相交（intersection），前两种情况的联合及相交。
  当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
  当服务器需要对多个索引做联合操作时（多个OR条件），通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并并扫描返回大量数据的时候。
更重要的是，优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如直接走全表扫描。
如果在EXPLAIN中看到有索引合并（type: index_merge），应该好好检查下查询和表的结构，看是不是已经是最优的。也可以通过参数optimizer_switch来关闭索引合并功能。也可以使用IGNORE INDEX提示让优化器来忽略掉某些索引。
  
  #### 选择合适的索引列顺序
  将选择性最高的列放到索引的最前列
####  聚簇索引
聚簇索引并不是一种单独的索引类型，二是一种数据存储方式。具体的细节依赖于其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。
当标有聚簇索引时，它的数据航实际上存放在索引的叶子页（leaf page）中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
InnoDB将通过主键狙击数据，被索引的列就是主键列。
优点：
1. 可以把先关数据保存在一起，减少磁盘IO
2. 数据访问更快。索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

缺点：
1. 最大限度的提高了I/O密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有了优势
2. 插入速度严重依赖于插入顺序。
3. 更新聚簇索引列的代缴很高，因为会强制InnoDB将诶个被更新的行一定到新的位置
4. 页分裂问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将改页分裂成两个页面来容纳改行，页分裂导致表占用更多的磁盘空间。
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者页分裂导致数据存储不连续
6. 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
7. 二级索引访问需要两次索引查询，而不是一次。

##### 聚簇和聚簇表的对比图
![enter description here][4]

##### 在InnoDB表中按主键顺序插入行

最好避免随机的（不连续，分布范围大）聚簇索引，特别是IO密集型的应用。

 ![enter description here][5]


 ![enter description here][6]
  
  使用InnoDB时应该尽可能按照主键顺序插入数据，并尽可能地使用单调增加的聚簇键的值来插入新行
  
#### 覆盖索引
  
  如果一个索引包含（或者说覆盖）所有所需查询字段的值，我们就称之为“覆盖索引”
  当发起一个被索引覆盖的查询（索引覆盖查询）时，在EXPLAIN的Extra列可以看到“Using index”的信息。
  个人的理解，你可以把你需要查询的字段放到一个多列索引中，这样查询时直接走索引，而不用再到行里面取字段。
  
#### 索引扫描

 只有当索引的列排序和order 不用自居的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能使用索引对结果做排序。

#### 冗余和重复索引

冗余索引的例子：
创建了(A, B)，在创建(A)，索引(A)即冗余
创建了(A, ID)，ID是主键，对InnoDB来说，主键已经包含在二级索引中，这也是冗余的

#### 技巧
##### 满足多列索引的条件

假设现有索引(A, B, C)，现有查询 select * from t where A=a and C = c;可改造为select * from t where A  = a and B in (b1, b2, ..bn) and C = c；这样就会走多列索引

### 索引的类型

#### 普通索引 index

#### 唯一索引 unique

#### 主键索引 primary

#### 全文索引 fulltext

### InnoDB与MyISAM索引异同

#### 相同点

都是采用B+树作为索引结构

#### 区别点

1. 主键索引区别：InnoDB的数据文件本身就是索引文件（聚簇索引）；MyISAM的索引和数据是分开的。
2. 辅助索引区别：InnoDB的辅助索引data域存储相应记录主键值而不是地址；MyISAM的辅助索引和主键索引没多大区别，data域存放的是数据记录的地址


### B-tree B+tree 红黑树区别 

### 为什么用B+tree做索引

http://tech.it168.com/a2011/0711/1216/000001216087_all.shtml

http://database.51cto.com/art/201504/473322_all.htm

http://tech.it168.com/a2011/0711/1216/000001216087_4.shtml

![enter description here][7]

1. 背景：索引文件很大，不可能全部存储在内存中，故要**存储到磁盘上**
2. 使用**磁盘I/O次数**评价索引结构的优劣的**标准**
3. 根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将**一个节点的大小设为等于一个页**，这样每个节点只需要一次I/O就可以完全载入。(在许多操作系统中，页得大小通常为4k)
4. B-Tree中一次检索**最多需要h-1次I/O**(根节点常驻内存)，渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小(通常不超过3)。
5. 红黑树这种结构，h明显要深的多。由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。


1. 评价一个索引好坏主要看IO的访问次数，B+树红黑树来说，树高很小（出度很大）即可以有效降低IO的访问次数。B+数的高度h=logd(n),d越大，h越小，查询效率越高。相对B树，B+树d可以很大，因为非叶子节点不存储数据，只存储key，在一个存储页上可以存储更多的key值。在每个页上可以存储更多的key，即d很大。
2. 外存按照页进行逻辑划分，页大小固定，当读入外存数据时，会根据局部性原理每次会预读连续的多页数据到内存。B+树的叶子节点是存储是连续和有序的，在查询时，尤其在范围查询时较少的IO次数可以访问到所需的数据

我的总结：
1. 出度大，书高低，减少io次数
2. 叶子连续有序，可利用磁盘预读，适用范围查询

### MySQL索引背后的数据结构及算法原理 （写的很好）

http://tech.it168.com/a2011/0711/1216/000001216087_all.shtml

### explain

#### Ref

http://www.cnblogs.com/xuanzhi201111/p/4175635.html
http://www.cnitblog.com/aliyiyi08/archive/2016/04/21/48878.html

#### 关键点

**type**

表示MySQL在表中找到所需行的方式，又称“访问类型”。

常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）

* ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
index: Full Index Scan，index与ALL区别为index类型只遍历索引树
* range:只检索给定范围的行，使用一个索引来选择行
* ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
* eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
* const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system
* NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

**key**
MySQL实际决定使用的索引

## 锁

http://blog.csdn.net/xifeijian/article/details/20313977

### 锁的分类

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

### MyISAM InnoDB区别

MyISAM不支持事务，只支持表锁
InnoDB支持事务，支持表锁和行锁


### MyISAM锁 表锁

#### 两种锁

表共享读锁（Table Read Lock）

表独占写锁（Table Write Lock）

#### 加锁时机

MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预

在用LOCK TABLES给表显式加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLES后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得SQL语句所需要的全部锁。这也正是MyISAM表不会出现死锁（Deadlock Free）的原因。

#### 整体串行，特定并发插入

MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。
当concurrent_insert设置为0时，不允许并发插入。
当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。
当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

#### 锁调度

写进程先获得锁

这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM 的调度行为。

### InnoDB锁

#### 查看锁争用情况

show status like 'innodb_row_lock%';

如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高

#### 行锁模式

共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

#### 加锁时机

意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)

对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

#### 行锁的实现方式

InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

1. 在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
2. 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的
3. 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
4. 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

#### 表锁使用时机

* 第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。
* 第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。

#### 死锁

发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数 innodb_lock_wait_timeout来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。

#### 减少死锁

* 尽量使用较低的隔离级别；
* 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；
* 选择合理的事务大小，小事务发生锁冲突的几率也更小；
* 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；
* 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；
* 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响；
* 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；
* 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。


  [1]: ./assets/mysql1.png "mysql1.png"
  [2]: ./assets/MySQL2.png "MySQL2.png"
  [3]: ./assets/mysql3.png "mysql3.png"
  [4]: ./assets/mysql.png "mysql.png"
  [5]: ./assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-06%20%E4%B8%8B%E5%8D%888.56.41.png "屏幕快照 2016-09-06 下午8.56.41.png"
  [6]: ./assets/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-06%20%E4%B8%8B%E5%8D%888.57.52.png "屏幕快照 2016-09-06 下午8.57.52.png"
  [7]: ./assets/b%E5%8A%A0%E6%A0%91.png "b加树.png"